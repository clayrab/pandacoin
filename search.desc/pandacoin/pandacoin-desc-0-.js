searchState.loadedDescShard("pandacoin", 0, "Contains the error value\nError returned by most functions.\nContains the success value\nA specialized <code>Result</code> type for operations.\nKeypair Store\nThis structure is a basic block, it should be 1-to-1 with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnumerated types of <code>Transaction</code>s to be handed by consensus\nInitial Treasury\nAppend <code>Block</code> to the index of <code>Blockchain</code> These <code>AddBlockEvent</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nget a block from the blockchain by hash\nget a block from the blockchain by id\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>Blockchain</code>\nremove blocks that are in fork branches and have become …\nThis class is used to store all blocks in a tree …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>BlocksDatabase</code>\nThis is the Clap options structure which stores all …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPath to key-file\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA (hashed) message input to an ECDSA signature\nA Secp256k1 public key, used for verification of signatures\nA global, static context to avoid repeatedly creating …\nAn ECDSA signature\nAdds the pk corresponding to <code>other</code> to the pk <code>self</code> in place …\nConverts the object to a mutable raw pointer for FFI …\nObtains a raw mutable pointer suitable for use with FFI …\nObtains a raw mutable pointer suitable for use with FFI …\nConverts the object to a raw pointer for FFI interfacing\nObtains a raw const pointer suitable for use with FFI …\nObtains a raw pointer suitable for use with FFI functions\nGets a reference to the underlying array\nAdds a second key to this one, returning the sum. Returns …\nAdds the keys in the provided slice together, returning …\nConverts a 32-byte hash directly to a message without …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a 64-byte compact-encoded byte slice to a …\nConverts a DER-encoded byte slice to a signature\nConverts a “lax DER”-encoded byte slice to a …\nCreates a new public key from a secret key.\n<strong>If you just want to sign an arbitrary message use </strong>…\nCreates a public key directly from a slice\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the object as an array is empty\nReturns the length of the object as an array\nHash the message string with sha256 for signing by …\nMuliplies the pk <code>self</code> in place by the scalar <code>other</code> Will …\nNegates the pk to the pk <code>self</code> in place Will return an …\nNormalizes a signature to a “low S” form. In ECDSA, …\nSerialize the key as a byte-encoded pair of values. In …\nSerializes the signature in compact format\nSerializes the signature in DER format\nSerialize the key as a byte-encoded pair of values, in …\nVerify a message signed by secp256k1. Message is a byte …\nVerify a message signed by secp256k1. Message is a plain …\nFork Manager\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nroll forward\nAn secp256k1 keypair for signing and verifying messages\nformats a Keypair for println!\nReturns the argument unchanged.\nCreate and return a keypair with  the given hex u8 array …\nCreate and return a keypair with  the given hex u8 array …\nGet the public key of the keypair in base58(i.e. address) …\nGet the public key of the keypair as …\nGet the private key as a hex-encoded string\nCalls <code>U::from(self)</code>.\nCreate and return a keypair with a randomly generated …\nHash and sign message bytes\nHash and sign a message string\nThis manages a keypair for the user through a CLI. It will …\nReturns the argument unchanged.\nget the keypair\nCalls <code>U::from(self)</code>.\nCreate new <code>KeypairStore</code>.\nCreate new <code>KeypairStore</code> for testing from existing wallet …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>LongestChainQueue</code>\nadd a transaction to the mempool. This doesn’t …\nReturns the argument unchanged.\nget the current sent of transactions that could be made …\nWe track the latest block id internally in Mempool so we …\nget a transaction from the mempool\nCalls <code>U::from(self)</code>.\nMake a miniblock containing tx from our mempool, but …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlthough it is technically possible to allow MiniBlocks …\nThis structure will keep track of the known miniblocks …\nAdd a mini block to the mempool and track all the output …\nmake a block from the spendable mini-blocks\nReturns the argument unchanged.\nReturns the argument unchanged.\nwhen requesting a miniblock from another peer we need to …\nget known inputs. Known inputs are in a miniblock which …\nget mini_blocks\nget unspendable_mini_block_hashes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSome of the mini_blocks in unspendable_mini_block_hashes …\nNeeds to make sure all the existing mini_blocks are still …\nif a mini_block which is already in unspendable …\nReturns address in <code>Slip</code>\nReturns amount of COIN in <code>Slip</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>OutputIdProto</code>\nReturns the <code>Slip</code>\nSets <code>txtype</code> to the provided enum value.\nNested message and enum types in <code>TransactionProto</code>.\nReturns the <code>Transaction</code> id the output originated from\nReturns the enum value of <code>txtype</code>, or the default if the …\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>TxType</code>, or <code>None</code> if <code>value</code> is not a …\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>TxType</code>.\nThis Mock RawBlock is used for testing Block Fee\nThis Mock RawBlock is used for testing the blockchain Set\nThis Mock RawBlock is used for testing the blockchain Set\nThis Mock RawBlock is used for testing the miniblock …\nThis Mock RawBlock is used for testing the UTXO Set\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAppend <code>Block</code> to the index of <code>Blockchain</code> These <code>AddBlockEvent</code>…\nReturns the argument unchanged.\nIf the block is in the fork\nIf the block is in the fork\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis is a mock impl of TimestampGenerator which can be …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA trait used for getting timestamps. The purpose of this …\nThis is simply a wrapper for the system clock which allows …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nValidate a transaction. fork_chains is only needed for …\nThe proto library will not decode to an array, only a …\nA hashmap storing everything needed to validate the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes the fee(leftover of output amount - input amount) …\nThis verifies that the corresponding outputs for the given …\nLoops through all the OutputIdProtos(inputs) and return …\nget total amount available from a Vec of Outputs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the output is Unspent(present in the …\nReturns true if the output is Unspent(present in the …\nCreate new <code>UtxoSet</code>\nThis is used to get the Output(<code>OutputProto</code>) which …\nRemove a block from the tip of the longest chain. Loop …\nRemoves a block from the tip of a fork chain. This is not …\nAdd a block to the tip of the longest chain. Loop through …\nAdd a block to the tip of a fork. Loop through the inputs …")